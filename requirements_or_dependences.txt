# requirements.txt
# Copiar este contenido en un archivo llamado requirements.txt

opencv-python>=4.8.0
mediapipe>=0.10.0
numpy>=1.21.0
pandas>=1.3.0
matplotlib>=3.5.0
seaborn>=0.11.0
scipy>=1.7.0
scikit-learn>=1.0.0

# ================================
# setup_environment.py
# Script para configurar el entorno

import subprocess
import sys
import os

def install_requirements():
    """Instala las dependencias necesarias"""
    print("🔧 Instalando dependencias necesarias...")
    
    requirements = [
        "opencv-python>=4.8.0",
        "mediapipe>=0.10.0", 
        "numpy>=1.21.0",
        "pandas>=1.3.0",
        "matplotlib>=3.5.0",
        "seaborn>=0.11.0",
        "scipy>=1.7.0",
        "scikit-learn>=1.0.0"
    ]
    
    for requirement in requirements:
        try:
            print(f"Instalando {requirement}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", requirement])
            print(f"✅ {requirement} instalado correctamente")
        except subprocess.CalledProcessError as e:
            print(f"❌ Error instalando {requirement}: {e}")
            return False
    
    return True

def check_camera():
    """Verifica que la cámara esté disponible"""
    print("📹 Verificando disponibilidad de cámara...")
    
    try:
        import cv2
        cap = cv2.VideoCapture(0)
        
        if not cap.isOpened():
            print("❌ No se pudo acceder a la cámara")
            print("Soluciones posibles:")
            print("1. Verificar que la cámara esté conectada")
            print("2. Cerrar otras aplicaciones que usen la cámara")
            print("3. Reiniciar el sistema")
            return False
        
        ret, frame = cap.read()
        if not ret:
            print("❌ La cámara está conectada pero no puede capturar imágenes")
            cap.release()
            return False
        
        height, width = frame.shape[:2]
        print(f"✅ Cámara disponible - Resolución: {width}x{height}")
        cap.release()
        return True
        
    except ImportError:
        print("❌ OpenCV no está instalado")
        return False

def create_project_structure():
    """Crea la estructura de carpetas del proyecto"""
    print("📁 Creando estructura de proyecto...")
    
    folders = [
        "data",
        "reports", 
        "exports",
        "comparisons"
    ]
    
    for folder in folders:
        if not os.path.exists(folder):
            os.makedirs(folder)
            print(f"✅ Carpeta creada: {folder}")
        else:
            print(f"📁 Carpeta ya existe: {folder}")

def run_system_check():
    """Ejecuta verificaciones del sistema"""
    print("🔍 Verificando sistema...")
    
    # Verificar Python
    python_version = sys.version_info
    print(f"Python version: {python_version.major}.{python_version.minor}.{python_version.micro}")
    
    if python_version.major < 3 or (python_version.major == 3 and python_version.minor < 8):
        print("⚠️  Advertencia: Se recomienda Python 3.8 o superior")
    else:
        print("✅ Versión de Python compatible")
    
    # Verificar sistema operativo
    import platform
    os_info = platform.system()
    print(f"Sistema operativo: {os_info}")
    
    if os_info == "Windows":
        print("✅ Windows detectado - Compatible")
    elif os_info == "Darwin":
        print("✅ macOS detectado - Compatible")
    elif os_info == "Linux":
        print("✅ Linux detectado - Compatible")
    else:
        print("⚠️  Sistema operativo no reconocido")

def main():
    """Función principal de configuración"""
    print("="*60)
    print("🚀 CONFIGURACIÓN DEL SISTEMA DE ANÁLISIS BIOMECÁNICO")
    print("="*60)
    
    # Verificar sistema
    run_system_check()
    print()
    
    # Instalar dependencias
    if install_requirements():
        print("✅ Todas las dependencias instaladas correctamente")
    else:
        print("❌ Error en la instalación de dependencias")
        return False
    
    print()
    
    # Verificar cámara
    if check_camera():
        print("✅ Cámara verificada correctamente")
    else:
        print("⚠️  Problemas con la cámara - el sistema funcionará pero no podrá capturar")
    
    print()
    
    # Crear estructura
    create_project_structure()
    
    print()
    print("="*60)
    print("🎉 CONFIGURACIÓN COMPLETADA")
    print("="*60)
    print("Para usar el sistema:")
    print("1. Ejecuta 'python jump_analyzer.py' para capturar datos")
    print("2. Ejecuta 'python data_analyzer.py' para analizar datos guardados")
    print("3. Los reportes se guardarán automáticamente")
    print("="*60)
    
    return True

if __name__ == "__main__":
    main()

# ================================
# demo_data_generator.py
# Generador de datos de demostración

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def generate_demo_jump_data(duration=5.0, sampling_rate=30):
    """
    Genera datos sintéticos de un salto para demostración
    Args:
        duration: Duración total en segundos
        sampling_rate: Frecuencia de muestreo en Hz
    """
    print("📊 Generando datos de demostración...")
    
    # Parámetros del salto simulado
    takeoff_time = 1.5  # Segundo en que ocurre el despegue
    flight_duration = 0.4  # Duración del vuelo
    landing_time = takeoff_time + flight_duration
    
    # Crear timeline
    t = np.linspace(0, duration, int(duration * sampling_rate))
    
    # Simular posición vertical del centro de masa
    com_y = np.ones_like(t) * 0.5  # Línea base
    
    # Agregar movimiento de salto
    for i, time_point in enumerate(t):
        if takeoff_time <= time_point <= landing_time:
            # Trayectoria parabólica durante el vuelo
            phase = (time_point - takeoff_time) / flight_duration
            com_y[i] = 0.5 - 0.15 * (4 * phase * (1 - phase))  # Parábola invertida
        elif time_point < takeoff_time:
            # Preparación (contra-movimiento)
            if time_point > takeoff_time - 0.5:
                prep_phase = (takeoff_time - time_point) / 0.5
                com_y[i] = 0.5 + 0.03 * prep_phase  # Ligero descenso
    
    # Simular posición horizontal (ligero movimiento)
    com_x = 0.5 + 0.02 * np.sin(t * 2) * np.exp(-t/3)
    
    # Simular ángulos articulares realistas
    # Ángulos de rodilla (90-160 grados típicamente)
    base_knee_angle = 140
    left_knee_angle = base_knee_angle + 10 * np.sin(t * 3) * np.exp(-t/2)
    right_knee_angle = base_knee_angle + 8 * np.sin(t * 3 + 0.1) * np.exp(-t/2)
    
    # Ángulos de cadera (120-180 grados típicamente)  
    base_hip_angle = 150
    left_hip_angle = base_hip_angle + 15 * np.sin(t * 2.5) * np.exp(-t/3)
    right_hip_angle = base_hip_angle + 12 * np.sin(t * 2.5 + 0.15) * np.exp(-t/3)
    
    # Simular fase aérea
    in_air = (t >= takeoff_time) & (t <= landing_time)
    
    # Calcular índices de simetría
    knee_diff = np.abs(left_knee_angle - right_knee_angle)
    hip_diff = np.abs(left_hip_angle - right_hip_angle)
    
    knee_symmetry = 100 - (knee_diff / ((left_knee_angle + right_knee_angle) / 2)) * 100
    hip_symmetry = 100 - (hip_diff / ((left_hip_angle + right_hip_angle) / 2)) * 100
    
    # Crear DataFrame
    demo_data = pd.DataFrame({
        'timestamp': t,
        'com_x': com_x,
        'com_y': com_y,
        'left_knee_angle': left_knee_angle,
        'right_knee_angle': right_knee_angle,
        'left_hip_angle': left_hip_angle,
        'right_hip_angle': right_hip_angle,
        'knee_symmetry': knee_symmetry,
        'hip_symmetry': hip_symmetry,
        'in_air': in_air
    })
    
    # Guardar datos de demostración
    filename = f"jump_analysis_demo_{int(datetime.now().timestamp())}.csv"
    demo_data.to_csv(filename, index=False)
    
    print(f"✅ Datos de demostración guardados como: {filename}")
    print(f"📊 Puntos de datos generados: {len(demo_data)}")
    print(f"⏱️  Duración simulada: {duration} segundos")
    print(f"🚀 Despegue simulado en: {takeoff_time}s")
    print(f"🛬 Aterrizaje simulado en: {landing_time}s")
    
    # Crear visualización de los datos generados
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    
    # Trayectoria COM
    axes[0,0].plot(t, com_y, 'b-', linewidth=2, label='COM Y')
    axes[0,0].axvline(takeoff_time, color='g', linestyle='--', label='Despegue')
    axes[0,0].axvline(landing_time, color='r', linestyle='--', label='Aterrizaje')
    axes[0,0].set_title('Trayectoria Vertical del Centro de Masa')
    axes[0,0].set_xlabel('Tiempo (s)')
    axes[0,0].set_ylabel('Posición Y')
    axes[0,0].legend()
    axes[0,0].grid(True, alpha=0.3)
    
    # Ángulos de rodilla
    axes[0,1].plot(t, left_knee_angle, 'g-', label='Rodilla Izq')
    axes[0,1].plot(t, right_knee_angle, 'orange', label='Rodilla Der')
    axes[0,1].set_title('Ángulos de Rodilla')
    axes[0,1].set_xlabel('Tiempo (s)')
    axes[0,1].set_ylabel('Ángulo (grados)')
    axes[0,1].legend()
    axes[0,1].grid(True, alpha=0.3)
    
    # Ángulos de cadera
    axes[1,0].plot(t, left_hip_angle, 'purple', label='Cadera Izq')
    axes[1,0].plot(t, right_hip_angle, 'brown', label='Cadera Der')
    axes[1,0].set_title('Ángulos de Cadera')
    axes[1,0].set_xlabel('Tiempo (s)')
    axes[1,0].set_ylabel('Ángulo (grados)')
    axes[1,0].legend()
    axes[1,0].grid(True, alpha=0.3)
    
    # Simetría
    axes[1,1].plot(t, knee_symmetry, 'cyan', label='Simetría Rodillas')
    axes[1,1].plot(t, hip_symmetry, 'magenta', label='Simetría Caderas')
    axes[1,1].set_title('Índices de Simetría')
    axes[1,1].set_xlabel('Tiempo (s)')
    axes[1,1].set_ylabel('Simetría (%)')
    axes[1,1].legend()
    axes[1,1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Guardar visualización
    plot_filename = f"demo_data_visualization_{int(datetime.now().timestamp())}.png"
    plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
    print(f"📈 Visualización guardada como: {plot_filename}")
    plt.show()
    
    return filename

if __name__ == "__main__":
    generate_demo_jump_data()
