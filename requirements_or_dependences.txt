# requirements.txt
# Copiar este contenido en un archivo llamado requirements.txt

opencv-python>=4.8.0
mediapipe>=0.10.0
numpy>=1.21.0
pandas>=1.3.0
matplotlib>=3.5.0
seaborn>=0.11.0
scipy>=1.7.0
scikit-learn>=1.0.0

# ================================
# setup_environment.py
# Script para configurar el entorno

import subprocess
import sys
import os

def install_requirements():
    """Instala las dependencias necesarias"""
    print("ğŸ”§ Instalando dependencias necesarias...")
    
    requirements = [
        "opencv-python>=4.8.0",
        "mediapipe>=0.10.0", 
        "numpy>=1.21.0",
        "pandas>=1.3.0",
        "matplotlib>=3.5.0",
        "seaborn>=0.11.0",
        "scipy>=1.7.0",
        "scikit-learn>=1.0.0"
    ]
    
    for requirement in requirements:
        try:
            print(f"Instalando {requirement}...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", requirement])
            print(f"âœ… {requirement} instalado correctamente")
        except subprocess.CalledProcessError as e:
            print(f"âŒ Error instalando {requirement}: {e}")
            return False
    
    return True

def check_camera():
    """Verifica que la cÃ¡mara estÃ© disponible"""
    print("ğŸ“¹ Verificando disponibilidad de cÃ¡mara...")
    
    try:
        import cv2
        cap = cv2.VideoCapture(0)
        
        if not cap.isOpened():
            print("âŒ No se pudo acceder a la cÃ¡mara")
            print("Soluciones posibles:")
            print("1. Verificar que la cÃ¡mara estÃ© conectada")
            print("2. Cerrar otras aplicaciones que usen la cÃ¡mara")
            print("3. Reiniciar el sistema")
            return False
        
        ret, frame = cap.read()
        if not ret:
            print("âŒ La cÃ¡mara estÃ¡ conectada pero no puede capturar imÃ¡genes")
            cap.release()
            return False
        
        height, width = frame.shape[:2]
        print(f"âœ… CÃ¡mara disponible - ResoluciÃ³n: {width}x{height}")
        cap.release()
        return True
        
    except ImportError:
        print("âŒ OpenCV no estÃ¡ instalado")
        return False

def create_project_structure():
    """Crea la estructura de carpetas del proyecto"""
    print("ğŸ“ Creando estructura de proyecto...")
    
    folders = [
        "data",
        "reports", 
        "exports",
        "comparisons"
    ]
    
    for folder in folders:
        if not os.path.exists(folder):
            os.makedirs(folder)
            print(f"âœ… Carpeta creada: {folder}")
        else:
            print(f"ğŸ“ Carpeta ya existe: {folder}")

def run_system_check():
    """Ejecuta verificaciones del sistema"""
    print("ğŸ” Verificando sistema...")
    
    # Verificar Python
    python_version = sys.version_info
    print(f"Python version: {python_version.major}.{python_version.minor}.{python_version.micro}")
    
    if python_version.major < 3 or (python_version.major == 3 and python_version.minor < 8):
        print("âš ï¸  Advertencia: Se recomienda Python 3.8 o superior")
    else:
        print("âœ… VersiÃ³n de Python compatible")
    
    # Verificar sistema operativo
    import platform
    os_info = platform.system()
    print(f"Sistema operativo: {os_info}")
    
    if os_info == "Windows":
        print("âœ… Windows detectado - Compatible")
    elif os_info == "Darwin":
        print("âœ… macOS detectado - Compatible")
    elif os_info == "Linux":
        print("âœ… Linux detectado - Compatible")
    else:
        print("âš ï¸  Sistema operativo no reconocido")

def main():
    """FunciÃ³n principal de configuraciÃ³n"""
    print("="*60)
    print("ğŸš€ CONFIGURACIÃ“N DEL SISTEMA DE ANÃLISIS BIOMECÃNICO")
    print("="*60)
    
    # Verificar sistema
    run_system_check()
    print()
    
    # Instalar dependencias
    if install_requirements():
        print("âœ… Todas las dependencias instaladas correctamente")
    else:
        print("âŒ Error en la instalaciÃ³n de dependencias")
        return False
    
    print()
    
    # Verificar cÃ¡mara
    if check_camera():
        print("âœ… CÃ¡mara verificada correctamente")
    else:
        print("âš ï¸  Problemas con la cÃ¡mara - el sistema funcionarÃ¡ pero no podrÃ¡ capturar")
    
    print()
    
    # Crear estructura
    create_project_structure()
    
    print()
    print("="*60)
    print("ğŸ‰ CONFIGURACIÃ“N COMPLETADA")
    print("="*60)
    print("Para usar el sistema:")
    print("1. Ejecuta 'python jump_analyzer.py' para capturar datos")
    print("2. Ejecuta 'python data_analyzer.py' para analizar datos guardados")
    print("3. Los reportes se guardarÃ¡n automÃ¡ticamente")
    print("="*60)
    
    return True

if __name__ == "__main__":
    main()

# ================================
# demo_data_generator.py
# Generador de datos de demostraciÃ³n

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def generate_demo_jump_data(duration=5.0, sampling_rate=30):
    """
    Genera datos sintÃ©ticos de un salto para demostraciÃ³n
    Args:
        duration: DuraciÃ³n total en segundos
        sampling_rate: Frecuencia de muestreo en Hz
    """
    print("ğŸ“Š Generando datos de demostraciÃ³n...")
    
    # ParÃ¡metros del salto simulado
    takeoff_time = 1.5  # Segundo en que ocurre el despegue
    flight_duration = 0.4  # DuraciÃ³n del vuelo
    landing_time = takeoff_time + flight_duration
    
    # Crear timeline
    t = np.linspace(0, duration, int(duration * sampling_rate))
    
    # Simular posiciÃ³n vertical del centro de masa
    com_y = np.ones_like(t) * 0.5  # LÃ­nea base
    
    # Agregar movimiento de salto
    for i, time_point in enumerate(t):
        if takeoff_time <= time_point <= landing_time:
            # Trayectoria parabÃ³lica durante el vuelo
            phase = (time_point - takeoff_time) / flight_duration
            com_y[i] = 0.5 - 0.15 * (4 * phase * (1 - phase))  # ParÃ¡bola invertida
        elif time_point < takeoff_time:
            # PreparaciÃ³n (contra-movimiento)
            if time_point > takeoff_time - 0.5:
                prep_phase = (takeoff_time - time_point) / 0.5
                com_y[i] = 0.5 + 0.03 * prep_phase  # Ligero descenso
    
    # Simular posiciÃ³n horizontal (ligero movimiento)
    com_x = 0.5 + 0.02 * np.sin(t * 2) * np.exp(-t/3)
    
    # Simular Ã¡ngulos articulares realistas
    # Ãngulos de rodilla (90-160 grados tÃ­picamente)
    base_knee_angle = 140
    left_knee_angle = base_knee_angle + 10 * np.sin(t * 3) * np.exp(-t/2)
    right_knee_angle = base_knee_angle + 8 * np.sin(t * 3 + 0.1) * np.exp(-t/2)
    
    # Ãngulos de cadera (120-180 grados tÃ­picamente)  
    base_hip_angle = 150
    left_hip_angle = base_hip_angle + 15 * np.sin(t * 2.5) * np.exp(-t/3)
    right_hip_angle = base_hip_angle + 12 * np.sin(t * 2.5 + 0.15) * np.exp(-t/3)
    
    # Simular fase aÃ©rea
    in_air = (t >= takeoff_time) & (t <= landing_time)
    
    # Calcular Ã­ndices de simetrÃ­a
    knee_diff = np.abs(left_knee_angle - right_knee_angle)
    hip_diff = np.abs(left_hip_angle - right_hip_angle)
    
    knee_symmetry = 100 - (knee_diff / ((left_knee_angle + right_knee_angle) / 2)) * 100
    hip_symmetry = 100 - (hip_diff / ((left_hip_angle + right_hip_angle) / 2)) * 100
    
    # Crear DataFrame
    demo_data = pd.DataFrame({
        'timestamp': t,
        'com_x': com_x,
        'com_y': com_y,
        'left_knee_angle': left_knee_angle,
        'right_knee_angle': right_knee_angle,
        'left_hip_angle': left_hip_angle,
        'right_hip_angle': right_hip_angle,
        'knee_symmetry': knee_symmetry,
        'hip_symmetry': hip_symmetry,
        'in_air': in_air
    })
    
    # Guardar datos de demostraciÃ³n
    filename = f"jump_analysis_demo_{int(datetime.now().timestamp())}.csv"
    demo_data.to_csv(filename, index=False)
    
    print(f"âœ… Datos de demostraciÃ³n guardados como: {filename}")
    print(f"ğŸ“Š Puntos de datos generados: {len(demo_data)}")
    print(f"â±ï¸  DuraciÃ³n simulada: {duration} segundos")
    print(f"ğŸš€ Despegue simulado en: {takeoff_time}s")
    print(f"ğŸ›¬ Aterrizaje simulado en: {landing_time}s")
    
    # Crear visualizaciÃ³n de los datos generados
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    
    # Trayectoria COM
    axes[0,0].plot(t, com_y, 'b-', linewidth=2, label='COM Y')
    axes[0,0].axvline(takeoff_time, color='g', linestyle='--', label='Despegue')
    axes[0,0].axvline(landing_time, color='r', linestyle='--', label='Aterrizaje')
    axes[0,0].set_title('Trayectoria Vertical del Centro de Masa')
    axes[0,0].set_xlabel('Tiempo (s)')
    axes[0,0].set_ylabel('PosiciÃ³n Y')
    axes[0,0].legend()
    axes[0,0].grid(True, alpha=0.3)
    
    # Ãngulos de rodilla
    axes[0,1].plot(t, left_knee_angle, 'g-', label='Rodilla Izq')
    axes[0,1].plot(t, right_knee_angle, 'orange', label='Rodilla Der')
    axes[0,1].set_title('Ãngulos de Rodilla')
    axes[0,1].set_xlabel('Tiempo (s)')
    axes[0,1].set_ylabel('Ãngulo (grados)')
    axes[0,1].legend()
    axes[0,1].grid(True, alpha=0.3)
    
    # Ãngulos de cadera
    axes[1,0].plot(t, left_hip_angle, 'purple', label='Cadera Izq')
    axes[1,0].plot(t, right_hip_angle, 'brown', label='Cadera Der')
    axes[1,0].set_title('Ãngulos de Cadera')
    axes[1,0].set_xlabel('Tiempo (s)')
    axes[1,0].set_ylabel('Ãngulo (grados)')
    axes[1,0].legend()
    axes[1,0].grid(True, alpha=0.3)
    
    # SimetrÃ­a
    axes[1,1].plot(t, knee_symmetry, 'cyan', label='SimetrÃ­a Rodillas')
    axes[1,1].plot(t, hip_symmetry, 'magenta', label='SimetrÃ­a Caderas')
    axes[1,1].set_title('Ãndices de SimetrÃ­a')
    axes[1,1].set_xlabel('Tiempo (s)')
    axes[1,1].set_ylabel('SimetrÃ­a (%)')
    axes[1,1].legend()
    axes[1,1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Guardar visualizaciÃ³n
    plot_filename = f"demo_data_visualization_{int(datetime.now().timestamp())}.png"
    plt.savefig(plot_filename, dpi=300, bbox_inches='tight')
    print(f"ğŸ“ˆ VisualizaciÃ³n guardada como: {plot_filename}")
    plt.show()
    
    return filename

if __name__ == "__main__":
    generate_demo_jump_data()
